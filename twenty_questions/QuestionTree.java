package twenty_questions;

/*
 * Ian Thorgeirson
 * Date: 6/07/2022
 * Class: CS 145 Hybrid: Data Structures w/ Java
 * Assignment: Lab 6: 20 Questions
 * Purpose: This program will play a simplified version of the popular
 * game "20 Questions." This class implements a yes/no guessing game
 * using binary trees that asks the client a series of yes or no questions. 
 */

import java.util.*;
import java.io.*;

public class QuestionTree {
	private int totalGames; // Tracks total # of games played in this instance
	private int gamesWon; // Tracks total # of correct guesses in this instance
	private UserInterface ui; // Allows us to use user input more easily
	private QuestionNode root; // The root of the current question tree

	// Initializes the QuestionTree object with appropriate default values.
	// Throws an IllegalArgumentException if passed object is null.
	public QuestionTree(UserInterface ui) {
		if (ui == null) {
			throw new IllegalArgumentException();
		}

		// Ints default to 0, so they aren't explicitly initialized here.
		this.ui = ui;
		root = new QuestionNode("Jedi");
	}

	// Plays a single, complete guessing game with the user. Game begins with the
	// root
	// node and moves left/right based on user answers. If the tree guesses
	// incorrectly,
	// the user is prompted for the correct answer, a question that would lead to
	// that answer,
	// and whether the answer to the question is yes or no. This is then added to
	// the tree.
	//
	// Precondition: We assume the tree is non-null and is valid.
	//
	// Throws an IllegalArgumentException if passed object is null.
	public void play() {
		root = play(root);
	}

	// Does the actual work for the play method; accepts a QuestionNode and returns
	// a
	// QuestionNode representing the new tree after a round has been played.
	//
	// Precondition: We assume the tree is non-null and is valid.
	private QuestionNode play(QuestionNode curr) {
		// Base case, we've reached an answer node and should ask if we're right.
		if (curr.isAnswer()) {
			ui.print("Would your object happen to be " + curr.data + "?");
			boolean yn = ui.nextBoolean();
			// If guess is right, yay! Increment number of games won.
			if (yn) {
				ui.println("I win!");
				gamesWon++;
			}
			// Else, prompt user for information to improve the tree and add the new nodes.
			// Note, we need to add a question node AND assign a node to it left/right
			// field,
			// and put the old answer in the opposite field.
			else {
				ui.print("I lose. What is your object?");
				String object = ui.nextLine();

				ui.print("Type a yes/no question to distinguish your item from " + curr.data + ":");
				String question = ui.nextLine();

				ui.print("And what is the answer for your object?");
				boolean dir = ui.nextBoolean();

				curr = fixNode(object, question, dir, curr);
			}

			totalGames++;
		}

		// Recursive case, we're still traversing the tree.
		else {
			ui.print(curr.data);
			boolean yn2 = ui.nextBoolean();
			if (yn2) {
				curr.left = play(curr.left);
			} else {
				curr.right = play(curr.right);
			}
		}

		return curr;
	}

	// Accepts a poor answer (node) and user input,
	// and returns a new question node with two correct answer nodes.
	private QuestionNode fixNode(String object, String question, boolean direction, QuestionNode curr) {
		QuestionNode usersNode;
		QuestionNode a = new QuestionNode(object);
		if (direction) {
			usersNode = new QuestionNode(question, a, curr);
		} else {
			usersNode = new QuestionNode(question, curr, a);
		}

		return usersNode;
	}

	// Replaces the current tree with a tree generated by reading the passed
	// scanner.
	// Precondition: We assume the file exists and is in the proper format.
	// Throws an IllegalArgumentException if passed object is null.
	public void load(Scanner input) {
		if (input == null) {
			throw new IllegalArgumentException();
		}

		root = loadHelper(input);
	}

	// Accepts a scanner, generates a tree and returns the root node.
	// Precondition: the file exists and is in the proper format. Scanner is not
	// null.
	private QuestionNode loadHelper(Scanner input) {
		String raw = input.nextLine();
		String prefix = raw.substring(0, 2);
		String data = raw.substring(2, raw.length());

		QuestionNode curr = new QuestionNode(data);
		// Answer nodes don't have children, so we only flesh out question nodes.
		if (prefix.startsWith("Q")) {
			curr.left = loadHelper(input);
			curr.right = loadHelper(input);
		}

		return curr;
	}

	// Produces a text file, saving the current question tree for retrieval later.
	// Each line corresponds to a node in the QuestionTree, in the same order as
	// a preorder traversal of the tree.
	// Questions preceded by 'Q:'
	// Answers are preceded by 'A:'
	//
	// Precondition: Passed printstream is not null.
	// Throws an IllegalArgumentException if passed object is null.
	public void save(PrintStream output) {
		if (output == null) {
			throw new IllegalArgumentException();
		}

		print(output, root);
	}

	// Accepts a printstream and a node; prints its data and children in preorder
	// order.
	// Precondition: Passed printstream is not null.
	private void print(PrintStream output, QuestionNode curr) {
		if (curr != null) {
			String prefix = (curr.isAnswer()) ? "A:" : "Q:"; // OBLIGATORY TERNARY

			output.println(prefix + curr.data);
			print(output, curr.left);
			print(output, curr.right);
		}
	}

	// Simply returns how many games have been played so far in this instance.
	public int totalGames() {
		return totalGames;
	}

	// Simply returns how many correct guesses have been made by the tree in this
	// instance.
	public int gamesWon() {
		return gamesWon;
	}
}